from collections import deque
import heapq
import math

class Graph():

    def __init__(self, V):
        self.V = V
        self.graph = [[0 for column in range(V)] \
                                for row in range(V)]


class GraphNode():
    def __init__(self):
        self.val = None
        self.neighbors = None

# BFS1 : BiPartie using queue
# def bipartie(myGraph):

# BFS 2: using priority queue => we need breadth first search and meanwhile, everytime we need to pop the min value
# def dijkstra_adjMat_iterative(targetNode,adjMat):
#     """
#
#     :param targetNode: the start node
#     :param adjMat: adjMat that uses to represent the graph
#     :return: list with length of number of node in the graph, in which element is the (shortestPath_to_targetNode,nodeName)
#     actually, we could treat for each of the node in graph, iterative other nodes to find the shortest possibility
#     so the time complexity is O(N^2) by iteration
#     """
#     costList = {}
#     costList[targetNode] = 0
#     traversed = set()
#     for node1 in range(len(adjMat)):
#         for node2 in range(node1 + 1,len(adjMat[targetNode])):
#             if node2 == targetNode or adjMat[targetNode][node2] == 0:
#                 continue
#             if node2 not in traversed:
#                 traversed.append(node2)
#                 costList[node2] = adjMat[targetNode][node2]
#             else:
#                 if costList[node] >




def max_len_prod_no_com_char_bfs2(listOflist):
    """
    given a list of list with the order of decreasing length of the sublist, find the two string which has no common
    element but has the max product of string length

    as the sublist was sorted by their length, so the final 2 string must be as front as possible
    there are 2 sublist in searching result, so its better to be 2 dimension searching range
           abced dfwk wer mbkq
    abced
    dfwk
    wer
    mbkq
    start from [0,0], every time expand an element in matrix [i,j], we generate[i+1,j],[i,j+1]
    following this path, the first expanded element with no common char would be the answer
    """

    start = len(listOflist[0]) * len(listOflist[0])
    heap = [(-start,(0,0))]
    heapq.heapify(heap)

    def is_common(list1, list2):
        shortList = list1 if len(list1) < len(list2) else list2
        longList = list1 if len(list1) >= len(list2) else list2
        mydict = {}
        for elem in shortList:
            if elem in mydict:
                mydict[elem] += 1
            else:
                mydict[elem] = 1
        for elem in longList:
            if elem in mydict:
                return True
            else:
                continue
        return False

    while len(heap) > 0:
        cur = heapq.heappop(heap)
        i = cur[1][0]
        j = cur[1][1]
        cur_list1 = listOflist[i]
        cur_list2 = listOflist[j]
        if is_common(cur_list1,cur_list2): # two sublist has common element
            if i + 1 < len(listOflist):
                add_list1 = listOflist[i + 1]
                heapq.heappush(heap,(-len(add_list1)*len(cur_list2),(i + 1,j)))
            if j + 1 < len(listOflist):
                add_list2 = listOflist[j + 1]
                heapq.heappush(heap,(-len(cur_list1)*len(add_list2),(i,j + 1)))
        else:
            return len(cur_list1)*len(cur_list2), (cur_list1,cur_list2)

    print "sublists has common char and target does not exist"
    return


def kth_smallest_of_function(k):
    """
    given 3^x * 5^y * 7^z, find the kth smallest number for this function assuming
    (x,y,z) starting from (0,0,0)

    similar to kth smallest in matrix, we need to use heap to find it
    expand (x,y,z), generate(x + 1, y + 1, z + 1)
    be careful for the dup, 5,5,5 could be generated by (4,5,5), (5,4,5) or (5,5,4)
    """
    def get_val(x,y,z):
        return pow(3,x) * pow(5,y) * pow(7,z)

    i = 0
    x = 0
    y = 0
    z = 0
    myset = set((x,y,z))

    heap = [(get_val(x,y,z),(x,y,z))]
    heapq.heapify(heap)
    result = [0]
    while i < k:
        cur = heapq.heappop(heap)
        result[0] = cur[0]
        cur_x = cur[1][0]
        cur_y = cur[1][1]
        cur_z = cur[1][2]
        print "the ",i," th smallest val is ",cur, " cur comb is ",cur_x,cur_y,cur_z
        if (cur_x + 1, cur_y, cur_z) not in myset:
            myset.add((cur_x + 1,cur_y,cur_z))
            heapq.heappush(heap,(get_val(cur_x+1,cur_y,cur_z),(cur_x+1,cur_y,cur_z)))
        if (cur_x,cur_y + 1,cur_z) not in myset:
            myset.add((cur_x,cur_y + 1,cur_z))
            heapq.heappush(heap,(get_val(cur_x ,cur_y + 1,cur_z),(cur_x,cur_y + 1,cur_z)))
        if (cur_x,cur_y,cur_z + 1) not in myset:
            myset.add((cur_x,cur_y,cur_z + 1))
            heapq.heappush(heap,(get_val(cur_x ,cur_y,cur_z + 1),(cur_x,cur_y,cur_z + 1)))
        i += 1

    return result[0]



"""
DFS
"""
def subset_of_unique_dfs(mylist):
    """
    :param list: a list of char first assuming the element in the list is unique
    :return: list of subset of the input list
    we could treated as tree, with ith level represent the ith element is selected or not (binary tree)
    when we reach the leafnode of the tree, append the result
    so we need to track the level of the tree where we currently at
    """
    def helper(thelist, level, curResult,result):
        print("at level ",level, "curResult is ",curResult)
        if level == len(thelist):
            result.append(list(curResult))
            return
        helper(thelist,level + 1,curResult,result)
        curResult.append(thelist[level])
        helper(thelist,level + 1,curResult,result)
        curResult.pop()
    result_list = []
    helper(mylist, 0,[],result_list)
    return result_list



def subset_of_dup_dfs(mylist):
    """
    :param list: a list of char first assuming the element in the list may not be unique
    :return: list of subset of the input list
    we could build a dictionary to save the frequency
    and append 0, 1,2,...freq of each item
    """
    # build dict to save the freq
    mydict = {}
    for item in mylist:
        if item in mydict:
            mydict[item] += 1
        else:
            mydict[item] = 1
    keys = mydict.keys()

    def helper(thedict,level, curResult,result):
        if level == len(mydict):
            result.append(list(curResult))
            return
        for i in range(mydict[keys[level]] + 1):
            curResult += [keys[level]]*i
            helper(thedict,level + 1,curResult,result)
            curResult[len(curResult) - i:len(curResult)] = []
    result_list = []
    helper(mydict, 0,[],result_list)
    return result_list

def subset_of_dup_noHashMap(mylist):
    """
    given a sorted list with dup (if not sort , sort first, so the duplication would be placed together)
    return all subset which each subset is unique
    compared with subset no dup
    the different with no dup one was if we came across some duplication, we need to skip them
    """
    if len(mylist) < 1:
        return

    def helper(mylist,level, curResult,result):
        if level == len(mylist):
            result.append(list(curResult))
            return

        # add cur letter
        curResult.append(mylist[level])
        helper(mylist,level + 1, curResult,result)
        while level < len(mylist) - 1 and curResult[-1] == mylist[level + 1]:
            level += 1
        curResult.pop()
        # not add cur letter
        helper(mylist,level + 1,curResult,result)
    final_result = []
    helper(mylist,0,[],final_result)
    return final_result

def combination(mylist,k):
    """
    return a list of combination with k elements in the array
    still subset problem
    they change is now the base case is curResult.len == k and level = len(mylist)(to avoid out of index)
    """
    if (len(mylist)) < k:
        return

    result = []
    def helper(mylist,level,curResult,result):
        if len(curResult) == k:
            result.append(list(curResult))
            return
        if level == len(mylist):
            return
        helper(mylist,level + 1, curResult,result)
        curResult.append(mylist[level])
        helper(mylist,level + 1, curResult, result)
        curResult.pop()

    helper(mylist,0,[],result)
    return result



def permutation_unique_dfs(mylist):
    """

    :param list: a list of unique char
    :return: list of list where each sublist is a permutation of the given list
    think it as at every level, we could swap(list[level],list[level+ i]) for i in 1:len(list) - level - 1
    time n*(n-1)*(n-2)...*1 , as the split decrease for 1 for every level increase by 1
    """
    if len(mylist) < 1:
        return

    final_result = []

    def helper(mylist,level,result):
        if level == len(mylist) - 1:
            result.append(list(mylist))
            return
        helper(mylist,level+1,result)
        for i in range(level+1,len(mylist)):
            mylist[level],mylist[i] = mylist[i],mylist[level]
            helper(mylist,level+1,result)
            mylist[level],mylist[i] = mylist[i],mylist[level]

    helper(mylist,0,final_result)
    return final_result


def permutation_dup_dfs(mylist):
    """

    :param list: a list of unique char
    :return: list of list where each sublist is a permutation of the given list
    different with no duplication is
    1. if the swapped elements are the same, then don't swap
     => at each iteration before swap, check mylist[level+i] != mylist[level]
    2. if any of the element's duplication has been swapped, then don't swap
    => use a set to document which element has been swapped at cur level

    """
    if len(mylist) < 1:
        return
    final_result = []

    def helper(mylist,level,result):
        if level == len(mylist) - 1:
            result.append(list(mylist))
            return
        helper(mylist,level+1,result)
        myset = set()
        for i in range(level+1,len(mylist)):
            if mylist[i] not in myset and mylist[i] != mylist[level]:
                myset.add(mylist[i])
                mylist[level],mylist[i] = mylist[i],mylist[level]
                helper(mylist,level+1,result)
                mylist[level],mylist[i] = mylist[i],mylist[level]
            else:
                continue
    helper(mylist,0,final_result)
    return final_result


def valid_parenthesis(n):
    """
    output the possible combination
    :return: list of possible combination
    there are 2*n levels in the recursion tree. Each level determines one position
    with restriction applied here that ) need to come after (, so when we put ) the result, we need to make sure
    the number of ( is larger than the number of )
    time complexity: O(4^n) space: O(n)

    """
    final_result = []

    def helper(n,n_left,n_right,level,curResult,result):
        if level == 2*n:
            result.append(list(curResult))
            return
        if n_left > 0:
            curResult[level] = '('
            helper(n,n_left - 1,n_right,level + 1,curResult,result)
        if n_right > n_left:
            curResult[level] = ')'
            helper(n,n_left,n_right - 1, level + 1,curResult,result)


    helper(n,n,n,0,[0]*2*n,final_result)
    return final_result


def valid_parenthesis_priority(n):
    """
    {[()]} or ({[]}), could not be ([)]
    :param n:
    :return:
    solution different with valid_parenthesis is need to use a stack to save the result
    """
    final_result = []
    stack = deque([])

    def helper(n, n_left1, n_right1,n_left2, n_right2,n_left3, n_right3,level,curStack,curResult,result):
        if level == 2 * 3 * n:
            result.append(list(curResult))
            return
        if n_left1 > 0:
            curResult[level] = "("
            curStack.append("(")
            helper(n, n_left1 - 1, n_right1, n_left2, n_right2,n_left3,n_right3,level + 1,curStack,curResult,result)
            curStack.pop()
        if n_left2 > 0:
            curResult[level] = "["
            curStack.append("[")
            helper(n,n_left1,n_right1,n_left2 - 1, n_right2,n_left3,n_right3,level + 1,curStack,curResult,result)
            curStack.pop()
        if n_left3 > 0:
            curResult[level] = "{"
            curStack.append("{")
            helper(n,n_left1,n_right1,n_left2, n_right2,n_left3 - 1,n_right3,level + 1,curStack,curResult,result)
            curStack.pop()
        if n_left1 < n_right1 and curStack[-1] == '(':
            curResult[level] = ")"
            curStack.pop()
            helper(n,n_left1,n_right1 - 1,n_left2, n_right2,n_left3,n_right3,level + 1,curStack,curResult,result)
            curStack.append("(")
        if n_left2 < n_right2 and curStack[-1] == '[':
            curResult[level] = "]"
            curStack.pop()
            helper(n,n_left1,n_right1,n_left2, n_right2 - 1,n_left3,n_right3,level + 1,curStack,curResult,result)
            curStack.append("[")
        if n_left3 < n_right3 and curStack[-1] == '{':
            curResult[level] = "}"
            curStack.pop()
            helper(n,n_left1,n_right1,n_left2, n_right2,n_left3,n_right3 - 1,level + 1,curStack,curResult,result)
            curStack.append("{")

    helper(n, n, n, n, n, n, n, 0, stack, [0] * 6 * n, final_result)
    return final_result




def valid_if_block(n):
    comb = []

    def helper(n,n_left,n_right,level,curResult,result):
        if level == 2*n:
            result.append(list(curResult))
            return
        if n_left > 0:
            curResult[level] = '{'
            helper(n,n_left - 1,n_right,level + 1,curResult,result)
        if n_right > n_left:
            curResult[level] = '}'
            helper(n,n_left,n_right - 1, level + 1,curResult,result)

    helper(n,n,n,0,[0]*2*n,comb)

    def print_comb(myComb):
        indent = 0
        for item in myComb:
            if item == '{':
                if indent == 0:
                    print 'if {'
                    indent += 2
                else:
                    print '\n' + ' '*indent + 'if {'
                    indent += 2
            if item == '}':
                print '\n' + ' '*indent + '}'
                if indent > 0:
                    indent -= 2
        return

    for mycomb in comb:
        print_comb(mycomb)
    return




def coin_combination(target,coins):
    """

    :param target: total amount of coin
    :param coins: available coins type 1 cent, 5 cent, 10 cent 25 cent....
    :return: list of list with each sublist is a combination

    using a dfs, where each level represents each type of coin, the number of split would be how many coins it could be filled
    time complexity: there are 4 level in the recursion tree,each level at most has 99 target split (when all filled with 1 cents)
    so the time complexity is O (target^level), with space complexity of the call stack is O(level)
    """
    final_result = []
    def helper(target,coins,level,curResult,result):
        if level == len(coins) - 1: # last level all filled with 1 cents
            curResult[level] = target
            result.append(list(curResult))
            return
        possible = target/coins[level]
        for i in range(possible + 1):
            remain = target - coins[level] * i
            curResult[level] = i
            helper(remain,coins,level + 1,curResult,result)
    helper(target,coins,0,[0,0,0,0],final_result)

    return final_result


def find_factor(target):
    """
    given a target integer, find the factor combination
    similar to coin combination, the difference is now we are now instead of finding sum equal to target,
    we are finding production equal to target
    1. we first need to find all the factors
    2. we second need to find combination
    :param myInt:
    :return:
    """
    def find_possible(int1, int2):
        count = 0
        while int1%int2 == 0:
            count += 1
            int1 = int1/int2
        return count

    factor = []
    for i in range(2, target):
        if target%i == 0:
            factor.append(i)
    print factor
    final_result = []


    def helper(factor,level,curResult,result,target):
        if level == -1:
            if target == 1:
                result.append(list(curResult))
            return
        possible = find_possible(target,factor[level])
        for i in range(0,possible + 1):
            curResult[level] = i
            remain = target/(pow(factor[level],i))
            helper(factor,level - 1, curResult,result,remain)

    helper(factor,len(factor) - 1,[0]*len(factor),final_result,target)
    return final_result

def copy_graph_bfs(node):
    """
    given a fully connected graph
    using bfs to copy the node
    expand node, generate its neighbors
    fit for the graph that is deep not wide (so dfs is more likely to overflow than bfs)
    for each generated node, if not exist in visited queue/hashmap, add to queue and add to hashmap

    """
    if node is None:
        return
    mydict = {}
    myqueue = deque([])
    myqueue.append(node)
    while len(myqueue) > 0:
        cur_node = myqueue.popleft()
        if cur_node not in mydict: # cur node hasn't been copied yet
            cur_node_copy = GraphNode()
            cur_node_copy.val = cur_node.val
            cur_node_copy.neighbors = cur_node.neighbors
            mydict[cur_node] = cur_node_copy
            for neighbor_node in cur_node.neighbors:
                myqueue.append(neighbor_node)
        else:
            continue
    return mydict.values()[0]


def copy_graph_dfs(node,lookup):
    """
    given a fully connected graph
    using dfs to copy the node
    using recursion
    fit for the graph that is wide not deep (so bfs is more likely to overflow than dfs)
    :return:
    """
    if node is None:
        return
    if node in lookup:
        return lookup[node]
    copy_node = GraphNode()
    copy_node.val = node.val
    lookup[node] = copy_node
    for neighbor in node.neighbors:
        copy_node.neighbor.append(copy_graph_dfs(neighbor,lookup))
    return copy_node




if __name__ == "__main__":
    myCostMat = [[0,1,0,0,1,0],[1,0,1,0,1,0],[0,1,0,1,0,0],[0,0,1,0,10,1],[0,0,0,1,0,0]]
    root = GraphNode()
    node1 = GraphNode()
    node2 = GraphNode()

    root.val = 0
    node1.val = 1
    node2.val = 2
    root.neighbors = [node1]
    node1.neighbors = [node2]
    node2.neighbors = [root]
    print("test copy_graph_bfs", copy_graph_bfs(root))
