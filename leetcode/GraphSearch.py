from collections import deque
import heapq
import math

class Graph():

    def __init__(self, V):
        self.V = V
        self.graph = [[0 for column in range(V)] \
                                for row in range(V)]


class GraphNode():
    def __init__(self):
        self.val = None
        self.neighbors = None

# BFS1 : BiPartie using queue
# def bipartie(myGraph):

# BFS 2: using priority queue => we need breadth first search and meanwhile, everytime we need to pop the min value
# def dijkstra_adjMat_iterative(targetNode,adjMat):
#     """
#
#     :param targetNode: the start node
#     :param adjMat: adjMat that uses to represent the graph
#     :return: list with length of number of node in the graph, in which element is the (shortestPath_to_targetNode,nodeName)
#     actually, we could treat for each of the node in graph, iterative other nodes to find the shortest possibility
#     so the time complexity is O(N^2) by iteration
#     """
#     costList = {}
#     costList[targetNode] = 0
#     traversed = set()
#     for node1 in range(len(adjMat)):
#         for node2 in range(node1 + 1,len(adjMat[targetNode])):
#             if node2 == targetNode or adjMat[targetNode][node2] == 0:
#                 continue
#             if node2 not in traversed:
#                 traversed.append(node2)
#                 costList[node2] = adjMat[targetNode][node2]
#             else:
#                 if costList[node] >




def max_len_prod_no_com_char_bfs2(listOflist):
    """
    given a list of list with the order of decreasing length of the sublist, find the two string which has no common
    element but has the max product of string length

    as the sublist was sorted by their length, so the final 2 string must be as front as possible
    there are 2 sublist in searching result, so its better to be 2 dimension searching range
           abced dfwk wer mbkq
    abced
    dfwk
    wer
    mbkq
    start from [0,0], every time expand an element in matrix [i,j], we generate[i+1,j],[i,j+1]
    following this path, the first expanded element with no common char would be the answer
    """

    start = len(listOflist[0]) * len(listOflist[0])
    heap = [(-start,(0,0))]
    heapq.heapify(heap)

    def is_common(list1, list2):
        shortList = list1 if len(list1) < len(list2) else list2
        longList = list1 if len(list1) >= len(list2) else list2
        mydict = {}
        for elem in shortList:
            if elem in mydict:
                mydict[elem] += 1
            else:
                mydict[elem] = 1
        for elem in longList:
            if elem in mydict:
                return True
            else:
                continue
        return False

    while len(heap) > 0:
        cur = heapq.heappop(heap)
        i = cur[1][0]
        j = cur[1][1]
        cur_list1 = listOflist[i]
        cur_list2 = listOflist[j]
        if is_common(cur_list1,cur_list2): # two sublist has common element
            if i + 1 < len(listOflist):
                add_list1 = listOflist[i + 1]
                heapq.heappush(heap,(-len(add_list1)*len(cur_list2),(i + 1,j)))
            if j + 1 < len(listOflist):
                add_list2 = listOflist[j + 1]
                heapq.heappush(heap,(-len(cur_list1)*len(add_list2),(i,j + 1)))
        else:
            return len(cur_list1)*len(cur_list2), (cur_list1,cur_list2)

    print "sublists has common char and target does not exist"
    return


def kth_smallest_of_function(k):
    """
    given 3^x * 5^y * 7^z, find the kth smallest number for this function assuming
    (x,y,z) starting from (0,0,0)

    similar to kth smallest in matrix, we need to use heap to find it
    expand (x,y,z), generate(x + 1, y + 1, z + 1)
    be careful for the dup, 5,5,5 could be generated by (4,5,5), (5,4,5) or (5,5,4)
    """
    def get_val(x,y,z):
        return pow(3,x) * pow(5,y) * pow(7,z)

    i = 0
    x = 0
    y = 0
    z = 0
    myset = set((x,y,z))

    heap = [(get_val(x,y,z),(x,y,z))]
    heapq.heapify(heap)
    result = 0
    while i < k:
        cur = heapq.heappop(heap)
        result = cur[0]
        cur_x = cur[1][0]
        cur_y = cur[1][1]
        cur_z = cur[1][2]
        print "the ",i," th smallest val is ",cur, " cur comb is ",cur_x,cur_y,cur_z
        if (cur_x + 1, cur_y, cur_z) not in myset:
            myset.add((cur_x + 1,cur_y,cur_z))
            heapq.heappush(heap,(get_val(cur_x+1,cur_y,cur_z),(cur_x+1,cur_y,cur_z)))
        if (cur_x,cur_y + 1,cur_z) not in myset:
            myset.add((cur_x,cur_y + 1,cur_z))
            heapq.heappush(heap,(get_val(cur_x ,cur_y + 1,cur_z),(cur_x,cur_y + 1,cur_z)))
        if (cur_x,cur_y,cur_z + 1) not in myset:
            myset.add((cur_x,cur_y,cur_z + 1))
            heapq.heappush(heap,(get_val(cur_x ,cur_y,cur_z + 1),(cur_x,cur_y,cur_z + 1)))
        i += 1

    return result



"""
DFS
"""
def subset_of_unique_dfs(mylist):
    """
    :param list: a list of char first assuming the element in the list is unique
    :return: list of subset of the input list
    we could treated as tree, with ith level represent the ith element is selected or not (binary tree)
    when we reach the leafnode of the tree, append the result
    so we need to track the level of the tree where we currently at
    """
    def helper(thelist, level, curResult,result):
        print("at level ",level, "curResult is ",curResult)
        if level == len(thelist):
            result.append(list(curResult))
            return
        helper(thelist,level + 1,curResult,result)
        curResult.append(thelist[level])
        helper(thelist,level + 1,curResult,result)
        curResult.pop()
    result_list = []
    helper(mylist, 0,[],result_list)
    return result_list



def subset_of_dup_dfs(mylist):
    """
    :param list: a list of char first assuming the element in the list may not be unique
    :return: list of subset of the input list
    we could build a dictionary to save the frequency
    and append 0, 1,2,...freq of each item
    """
    # build dict to save the freq
    mydict = {}
    for item in mylist:
        if item in mydict:
            mydict[item] += 1
        else:
            mydict[item] = 1
    keys = mydict.keys()

    def helper(thedict,level, curResult,result):
        if level == len(mydict):
            result.append(list(curResult))
            return
        for i in range(mydict[keys[level]] + 1):
            curResult += [keys[level]]*i
            helper(thedict,level + 1,curResult,result)
            curResult[len(curResult) - i:len(curResult)] = []
    result_list = []
    helper(mydict, 0,[],result_list)
    return result_list

def subset_of_dup_noHashMap(mylist):
    """
    given a sorted list with dup (if not sort , sort first, so the duplication would be placed together)
    return all subset which each subset is unique
    compared with subset no dup
    the different with no dup one was if we came across some duplication, we need to skip them
     they change is now the base case is curResult.len == k and level = len(mylist)(to avoid out of index)
    note that in the helper function, we must recursive on add cur element first  and move level pointer,
     and then recursive on not add in the cur element
    if we switch the order, then it will not work
    """
    if len(mylist) < 1:
        return

    def helper(mylist,level, curResult,result):
        if level == len(mylist):
            result.append(list(curResult))
            return

        # add cur letter
        curResult.append(mylist[level])
        helper(mylist,level + 1, curResult,result)
        while level < len(mylist) - 1 and curResult[-1] == mylist[level + 1]:
            level += 1
        curResult.pop()
        # not add cur letter
        helper(mylist,level + 1,curResult,result)
    final_result = []
    helper(mylist,0,[],final_result)
    return final_result

def combination(mylist,k):
    """
    return a list of combination with k elements in the array
    still subset problem

    """
    if (len(mylist)) < k:
        return

    result = []
    def helper(mylist,level,curResult,result):
        if len(curResult) == k:
            result.append(list(curResult))
            return
        if level == len(mylist):
            return
        helper(mylist,level + 1, curResult,result)
        curResult.append(mylist[level])
        helper(mylist,level + 1, curResult, result)
        curResult.pop()

    helper(mylist,0,[],result)
    return result


def comb_dup(mylist,k):
    """
    see the note on subset dup one
    same logic here
    :param mylist:
    :param k:
    :return:
    """
    if len(mylist) < k :
        print 'invalid input'
        return
    result = []
    def helper(mylist,level,k,curResult,result):
        if len(curResult) == k:
            result.append(list(curResult))
            return
        if level == len(mylist):
            return


        # add cur level element
        curResult.append(mylist[level])
        helper(mylist,level + 1, k, curResult,result)
        while level < len(mylist) - 1 and curResult[-1] == mylist[level + 1]:
            level += 1
        curResult.pop()

        # not add cur level element
        helper(mylist,level + 1, k,curResult,result)
    helper(mylist,0,k,[],result)
    return result



def permutation_unique_dfs(mylist):
    """

    :param list: a list of unique char
    :return: list of list where each sublist is a permutation of the given list
    think it as at every level, we could swap(list[level],list[level+ i]) for i in 1:len(list) - level - 1
    time n*(n-1)*(n-2)...*1 , as the split decrease for 1 for every level increase by 1
    """
    if len(mylist) < 1:
        return

    final_result = []

    def helper(mylist,level,result):
        if level == len(mylist) - 1:
            result.append(list(mylist))
            return
        helper(mylist,level+1,result)
        for i in range(level+1,len(mylist)):
            mylist[level],mylist[i] = mylist[i],mylist[level]
            helper(mylist,level+1,result)
            mylist[level],mylist[i] = mylist[i],mylist[level]

    helper(mylist,0,final_result)
    return final_result


def permutation_dup_dfs(mylist):
    """

    :param list: a list of unique char
    :return: list of list where each sublist is a permutation of the given list
    different with no duplication is
    1. if the swapped elements are the same, then don't swap
     => at each iteration before swap, check mylist[level+i] != mylist[level]
    2. if any of the element's duplication has been swapped, then don't swap
    => use a set to document which element has been swapped at cur level

    """
    if len(mylist) < 1:
        return
    final_result = []

    def helper(mylist,level,result):
        if level == len(mylist) - 1:
            result.append(list(mylist))
            return
        helper(mylist,level+1,result)
        myset = set()
        for i in range(level+1,len(mylist)):
            if mylist[i] not in myset and mylist[i] != mylist[level]:
                myset.add(mylist[i])
                mylist[level],mylist[i] = mylist[i],mylist[level]
                helper(mylist,level+1,result)
                mylist[level],mylist[i] = mylist[i],mylist[level]
            else:
                continue
    helper(mylist,0,final_result)
    return final_result


def valid_parenthesis(n):
    """
    output the possible combination
    :return: list of possible combination
    there are 2*n levels in the recursion tree. Each level determines one position
    with restriction applied here that ) need to come after (, so when we put ) the result, we need to make sure
    the number of ( is larger than the number of )
    time complexity: O(4^n) space: O(n)

    """
    final_result = []

    def helper(n,n_left,n_right,level,curResult,result):
        if level == 2*n:
            result.append(list(curResult))
            return
        if n_left > 0:
            curResult[level] = '('
            helper(n,n_left - 1,n_right,level + 1,curResult,result)
        if n_right > n_left:
            curResult[level] = ')'
            helper(n,n_left,n_right - 1, level + 1,curResult,result)


    helper(n,n,n,0,[0]*2*n,final_result)
    return final_result


def valid_parenthesis_priority(n):
    """
    {[()]} or ({[]}), could not be ([)]
    :param n:
    :return:
    solution different with valid_parenthesis is need to use a stack to save the result
    """
    final_result = []
    stack = deque([])

    def helper(n, n_left1, n_right1,n_left2, n_right2,n_left3, n_right3,level,curStack,curResult,result):
        if level == 2 * 3 * n:
            result.append(list(curResult))
            return
        if n_left1 > 0:
            curResult[level] = "("
            curStack.append("(")
            helper(n, n_left1 - 1, n_right1, n_left2, n_right2,n_left3,n_right3,level + 1,curStack,curResult,result)
            curStack.pop()
        if n_left2 > 0:
            curResult[level] = "["
            curStack.append("[")
            helper(n,n_left1,n_right1,n_left2 - 1, n_right2,n_left3,n_right3,level + 1,curStack,curResult,result)
            curStack.pop()
        if n_left3 > 0:
            curResult[level] = "{"
            curStack.append("{")
            helper(n,n_left1,n_right1,n_left2, n_right2,n_left3 - 1,n_right3,level + 1,curStack,curResult,result)
            curStack.pop()
        if n_left1 < n_right1 and curStack[-1] == '(':
            curResult[level] = ")"
            curStack.pop()
            helper(n,n_left1,n_right1 - 1,n_left2, n_right2,n_left3,n_right3,level + 1,curStack,curResult,result)
            curStack.append("(")
        if n_left2 < n_right2 and curStack[-1] == '[':
            curResult[level] = "]"
            curStack.pop()
            helper(n,n_left1,n_right1,n_left2, n_right2 - 1,n_left3,n_right3,level + 1,curStack,curResult,result)
            curStack.append("[")
        if n_left3 < n_right3 and curStack[-1] == '{':
            curResult[level] = "}"
            curStack.pop()
            helper(n,n_left1,n_right1,n_left2, n_right2,n_left3,n_right3 - 1,level + 1,curStack,curResult,result)
            curStack.append("{")

    helper(n, n, n, n, n, n, n, 0, stack, [0] * 6 * n, final_result)
    return final_result


def remove_invalid_parenthesis(mystr):
    """
    given a str of parenthesis, make it to valid string with minimum char removed
    if the string is )()()) => ()()
    (()())( => (()())(
    step1: check if the str is valid or not : 1) at any level, num_left >= num_right 2) and the end: num_left == num_right
    step2: note down the invalid number of left and right parenthesis (could be done in step1 )
    step3: running dfs and prune for dup (for consecutive left/right, remove either of those would be the same)

    :param str:
    :return:
    time complexity O(n + 2^n)
    """
    mylist = list(mystr)
    # step1 and step2
    l_count = 0
    r_count = 0
    r_invalid = 0
    for i in range(0,len(mylist)):
        if mylist[i] == "(":
            l_count += 1
        elif mylist[i] == ")":
            r_count += 1
        if r_count > l_count:
            r_invalid += 1
            r_count -= 1
    l_invalid = l_count - r_count

    # l_valid = l_count - l_invalid and r_valid = l_valid
    # corr_len = l_valid + r_valid

    def helper(mylist,level,l_invalid,r_invalid,left_open,curResult,result):
        """

        :param mylist: original list
        :param level: index
        :param l_invalid: # of invalid ( so far
        :param r_invalid: # of invalid ) so far
        :param left_open: # unmatched pairs
        :param curResult:
        :param result:
        :return:
        """
        # base case 1: generate valid output
        if level == len(mylist):
            if l_invalid == 0 and r_invalid == 0 and left_open == 0:
                result.append(list(curResult))
                return
            else:
                return
        # base case 2: prune
        if l_invalid < 0 or r_invalid < 0 or left_open < 0:
            return

        # dfs
        curChar = mylist[level]

        # remove curchar
        if curChar == "(":
            helper(mylist, level + 1,l_invalid - 1,r_invalid,left_open,curResult,result)
            while level < len(mylist) - 1 and mylist[level] == mylist[level + 1]:
                level += 1
        elif curChar == ")":
            helper(mylist, level + 1,l_invalid,r_invalid - 1,left_open,curResult,result)
            while level < len(mylist) - 1 and mylist[level] == mylist[level + 1]:
                level += 1
        else:# curchar is not parenthesis
            curResult.append(curChar)
            helper(mylist, level + 1,l_invalid,r_invalid,left_open,curResult,result)
        # keep curchar
        curResult.append(curChar)
        if curChar == "(":
            helper(mylist, level + 1,l_invalid,r_invalid,left_open + 1,curResult,result)
        elif curChar == ")":
            helper(mylist, level + 1,l_invalid,r_invalid,left_open - 1,curResult,result)
        else:
            helper(mylist, level + 1,l_invalid,r_invalid,left_open,curResult,result)
        curResult.pop()
    if l_invalid == 0 and r_invalid == 0:
        return mystr
    else:
        result = []
        helper(mylist,0,l_invalid,r_invalid,0,[],result)
        return [''.join(x) for x in result]

def valid_if_block(n):
    comb = []

    def helper(n,n_left,n_right,level,curResult,result):
        if level == 2*n:
            result.append(list(curResult))
            return
        if n_left > 0:
            curResult[level] = '{'
            helper(n,n_left - 1,n_right,level + 1,curResult,result)
        if n_right > n_left:
            curResult[level] = '}'
            helper(n,n_left,n_right - 1, level + 1,curResult,result)

    helper(n,n,n,0,[0]*2*n,comb)

    def print_comb(myComb):
        indent = 0
        for item in myComb:
            if item == '{':
                if indent == 0:
                    print 'if {'
                    indent += 2
                else:
                    print '\n' + ' '*indent + 'if {'
                    indent += 2
            if item == '}':
                print '\n' + ' '*indent + '}'
                if indent > 0:
                    indent -= 2
        return

    for mycomb in comb:
        print_comb(mycomb)
    return




def coin_combination(target,coins):
    """

    :param target: total amount of coin
    :param coins: available coins type 1 cent, 5 cent, 10 cent 25 cent....
    :return: list of list with each sublist is a combination

    using a dfs, where each level represents each type of coin, the number of split would be how many coins it could be filled
    time complexity: there are 4 level in the recursion tree,each level at most has 99 target split (when all filled with 1 cents)
    so the time complexity is O (target^level), with space complexity of the call stack is O(level)
    """
    final_result = []
    def helper(target,coins,level,curResult,result):
        if level == len(coins) - 1: # last level all filled with 1 cents
            curResult[level] = target
            result.append(list(curResult))
            return
        possible = target/coins[level]
        for i in range(possible + 1):
            remain = target - coins[level] * i
            curResult[level] = i
            helper(remain,coins,level + 1,curResult,result)
    helper(target,coins,0,[0,0,0,0],final_result)

    return final_result


def find_factor(target):
    """
    given a target integer, find the factor combination
    similar to coin combination, the difference is now we are now instead of finding sum equal to target,
    we are finding production equal to target
    1. we first need to find all the factors
    2. we second need to find combination
    :param myInt:
    :return:
    """
    def find_possible(int1, int2):
        count = 0
        while int1%int2 == 0:
            count += 1
            int1 = int1/int2
        return count

    factor = []
    for i in range(2, target):
        if target%i == 0:
            factor.append(i)
    print factor
    final_result = []


    def helper(factor,level,curResult,result,target):
        if level == -1:
            if target == 1:
                result.append(list(curResult))
            return
        possible = find_possible(target,factor[level])
        for i in range(0,possible + 1):
            curResult[level] = i
            remain = target/(pow(factor[level],i))
            helper(factor,level - 1, curResult,result,remain)

    helper(factor,len(factor) - 1,[0]*len(factor),final_result,target)
    return final_result

def copy_graph_bfs(node):
    """
    given a fully connected graph
    using bfs to copy the node
    expand node, generate its neighbors
    fit for the graph that is deep not wide (so dfs is more likely to overflow than bfs)
    for each generated node, if not exist in visited queue/hashmap, add to queue and add to hashmap

    """
    if node is None:
        return
    mydict = {}
    myqueue = deque([])
    myqueue.append(node)
    while len(myqueue) > 0:
        cur_node = myqueue.popleft()
        if cur_node not in mydict: # cur node hasn't been copied yet
            cur_node_copy = GraphNode()
            cur_node_copy.val = cur_node.val
            cur_node_copy.neighbors = cur_node.neighbors
            mydict[cur_node] = cur_node_copy
            for neighbor_node in cur_node.neighbors:
                myqueue.append(neighbor_node)
        else:
            continue
    return mydict.values()[0]


def copy_graph_dfs(node,lookup):
    """
    given a fully connected graph
    using dfs to copy the node
    using recursion
    fit for the graph that is wide not deep (so bfs is more likely to overflow than dfs)
    :return:
    """
    if node is None:
        return
    if node in lookup:
        return lookup[node]
    copy_node = GraphNode()
    copy_node.val = node.val
    lookup[node] = copy_node
    for neighbor in node.neighbors:
        copy_node.neighbor.append(copy_graph_dfs(neighbor,lookup))
    return copy_node


"""
Traverse a matrix problem
# non- direction (# of island)
# direction (maximum exchange of currency)

"""
def num_of_island(mymat):

    can_explore = [[True for i in range(len(mymat[0]))] for j in range(len(mymat))]

    num_of_island = 0

    def helper(mymat,cur_row,cur_col,can_explore):
        if cur_row >= len(mymat) or cur_row < 0 or cur_col >= len(mymat[0]) or cur_col < 0 or can_explore[cur_row][cur_col] == False:
            return

        if can_explore[cur_row][cur_col] and mymat[cur_row][cur_col] == 0:
            can_explore[cur_row][cur_col] = False
            return

        if can_explore[cur_row][cur_col] and mymat[cur_row][cur_col] == 1:
            can_explore[cur_row][cur_col] = False
            helper(mymat,cur_row + 1,cur_col,can_explore)
            helper(mymat,cur_row,cur_col + 1,can_explore)
            helper(mymat,cur_row - 1,cur_col,can_explore)
            helper(mymat,cur_row,cur_col - 1,can_explore)

    for i in range(len(mymat)):
        for j in range(len(mymat[0])):
            if can_explore[i][j] and mymat[i][j] == 1:
                print i,j
                helper(mymat,i,j,can_explore)
                num_of_island += 1
            else: continue
    return num_of_island


def surrounded_region(myMat):
    """
    given a 0 1 matrix, turn the surrounded 0 to 1
    note that the 0 on boundary cannot be surrounded

    similar with num_Of_island with the approach of traversal the matrix
    solution:
    step1 find the connect 0 with boarder and mark then as 2 => dfs
    step2 scan the matrix, change 0 to 1 and change 2 to 0
    return new matrix

    time: o(m*n)

    :param myMat:
    :return:
    """
    can_explore = [[True for i in range(len(myMat[0]))] for j in range(len(myMat))]

    def helper(myMat,cur_row,cur_col, can_explore):
        if cur_row >= len(myMat) or cur_col >= len(myMat[0]) or cur_row < 0 or cur_col < 0 or can_explore[cur_row][cur_col] == False:
            return
        if myMat[cur_row][cur_col] == 1:
            can_explore[cur_row][cur_col] == False
            return
        if myMat[cur_row][cur_col] == 0:
            can_explore[cur_row][cur_col] == False
            myMat[cur_row][cur_col] = 2
            helper(myMat,cur_row + 1,cur_col,can_explore)
            helper(myMat,cur_row,cur_col + 1,can_explore)
            helper(myMat,cur_row - 1,cur_col,can_explore)
            helper(myMat,cur_row,cur_col - 1,can_explore)

    # dfs not on all matrix, but only on the boarder of the matrix
    for j in range(len(myMat[0])):
        if can_explore[0][j] and myMat[0][j] == 0:
            helper(myMat,0,j,can_explore)
        if can_explore[len(myMat) - 1][j] and myMat[len(myMat) - 1][j] == 0:
            helper(myMat,len(myMat) - 1,j,can_explore)
    for i in range(len(myMat)):
        if can_explore[i][0] and myMat[i][0] == 0:
            helper(myMat,i,0,can_explore)
        if can_explore[i][len(myMat[0]) - 1] and myMat[i][len(myMat[0]) - 1] == 0:
            helper(myMat,i,len(myMat[0]) - 1,can_explore)

    # scan the matrix again
    for i in range(len(myMat)):
        for j in range(len(myMat[0])):
            if myMat[i][j] == 1:
                continue
            elif myMat[i][j] == 0:
                myMat[i][j] = 1
            else: # myMat[i][j] == 2
                myMat[i][j] = 0
    return myMat


def expression_operator_1(mystr,target):
    """

    :param mystr: given a string of numbers and the expression result of target
    output : list of valid expressions, expression could be linked by +,-
    :param target:
    :return:
    it is similar with the 99 cents problem
    for every recursion/level, we know the current val and res = target - cur
    for every step we need to save
    1. cur_num: mylist[level]
    2. prev: before including cur_num, the value of the expression
    3. the operator 1) + 2) - 3) space (which means, 1 2 =  12)

    time complexity O(3^n) => 3 splits with n level (+,-,join)
    """
    if len(mystr) < 1:
        return

    result = []

    def helper(myStr,level,prev,curResult,result,target):
        # basecase:
        print level,prev,curResult,target
        if level == len(myStr):
            if target == 0:
                result.append(list(curResult))
                return
            else:
                return

        # recursion
        for i in range(1,len(myStr) - level + 1):
            cur_num = int(myStr[level:level+i])
            if len(curResult) == 0:
                curResult.append(myStr[level:level+i])
                helper(myStr,level + i, prev + cur_num,curResult,result,target - cur_num)
                curResult.pop()
            else:
                curResult.append(str("+" + myStr[level:level+i]))
                helper(myStr,level + i, prev + cur_num,curResult,result,target - cur_num)
                curResult.pop()
                curResult.append(str("-" + myStr[level:level+i]))
                helper(myStr,level + i, prev - cur_num,curResult,result,target + cur_num)
                curResult.pop()
    helper(mystr, 0, 0, [], result, target)

    return [''.join(x) for x in result]

def expression_operator_2(mystr,target): # has bug
    """

    :param mystr: given a string of numbers and the expression result of target
    output : list of valid expressions, expression could be linked by +,-,*
    :param target:
    :return:
    it is similar with the 99 cents problem
    for every recursion/level, we know the current val and res = target - cur
    for every step we need to save
    1. cur_num: mylist[level]
    2. prev: before including cur_num, the value of the expression
    3. the operator 1) + 2) - 3) space (which means, 1 2 =  12)

    time complexity O(4^n) => 3 splits with n level (+,-,*,join)
    """
    if len(mystr) < 1:
        return

    result = []

    def helper(myStr,level,prev,curResult,result,target):
        # basecase:
        print level,prev,curResult,target
        if level == len(myStr):
            if target == 0:
                result.append(list(curResult))
                return
            else:
                return

        # recursion
        for i in range(1,len(myStr) - level + 1):
            cur_num = int(myStr[level:level+i])
            if len(curResult) == 0:
                curResult.append(myStr[level:level+i])
                helper(myStr,level + i, prev + cur_num,curResult,result,target - cur_num)
                curResult.pop()
            else:
                curResult.append(str("+" + myStr[level:level+i]))
                helper(myStr,level + i, prev + cur_num,curResult,result,target - cur_num)
                curResult.pop()
                curResult.append(str("-" + myStr[level:level+i]))
                helper(myStr,level + i, prev - cur_num,curResult,result,target + cur_num)
                curResult.pop()
    helper(mystr, 0, 0, [], result, target)

    return [''.join(x) for x in result]


def course_schedule(n,prereq_list):
    """
    find whether it is possible for taking all courses given prerequisite
    [2,[0,1]], possible
    2,[[0,1],[1,0]] impossible

    the course and prerequisite was given as graph edge, we need to find whether there is a cycle in the given graph
    if no cycle, then possible, otherwise impossible

    bfs: using a list of n to save number of pre-requisite of each courses
        create a queue to save courses does not requie prerequisite
        while len(queue) != 0:
            cur_course = pop queue
            iterate all courses to see if there is courses has pre-requsite is cur_courses: if so, reduce the number of
            prerequisite courses for current iterating course by 1, if after reducing, the prerequiiste couse is 0,
            then number of no prerequisite +=1
        finally judge if number of no prerequisite is n

    dfs: set up a visit flag, 0 is not explored, 1 is that course is possible to take , otherwise -1
        build a dict: key: course i, val: list of its prerequisite
        for i in range(n):
            run dfs(map, visit, i) => if return true means possible to take i and false: impossible


    :param n:
    :param couresList:
    :return:
    time: O(n + n + len(prereq))
    """
    if len(prereq_list) < 1:
        return True

    # build a dict:
    mydict = {}
    visit = [0] * n
    for item in prereq_list:
        if item[0] in mydict:
            mydict[item[0]].append(item[1])
        else:
            mydict[item[0]] = [item[1]]

    # create helper:
    def helper(thedict, visitList,i):
        if visitList[i] == -1:
            return False
        if visitList[i] == 1:
            return True
        visit[i] = -1
        if i in thedict:
            for j in thedict[i]:
                if helper(thedict, visitList,j):
                    continue
                else:
                    return False
        visitList[i] = 1
        return True
    # starting dfs
    for i in range(n):
        if helper(mydict,visit,i) == False:
            return False
    return True


if __name__ == "__main__":

    myCostMat = [[0,1,0,0,1,0],[1,0,1,0,1,0],[0,1,0,1,0,0],[0,0,1,0,10,1],[0,0,0,1,0,0]]
    root = GraphNode()
    node1 = GraphNode()
    node2 = GraphNode()

    root.val = 0
    node1.val = 1
    node2.val = 2
    root.neighbors = [node1]
    node1.neighbors = [node2]
    node2.neighbors = [root]
    print("test copy_graph_bfs", copy_graph_bfs(root))
